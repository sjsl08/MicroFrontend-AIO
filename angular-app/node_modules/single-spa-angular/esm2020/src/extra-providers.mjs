import { Injectable, Inject } from '@angular/core';
import { BrowserPlatformLocation, PlatformLocation, DOCUMENT, } from '@angular/common';
import * as i0 from "@angular/core";
export class SingleSpaPlatformLocation extends BrowserPlatformLocation {
    constructor() {
        super(...arguments);
        // This is a simple marker that helps us to ignore PopStateEvents
        // that was not dispatched by the browser.
        this.skipNextPopState = false;
        this.source = 'Window.addEventListener:popstate';
    }
    pushState(state, title, url) {
        this.skipNextPopState = true;
        super.pushState(state, title, url);
    }
    replaceState(state, title, url) {
        this.skipNextPopState = true;
        super.replaceState(state, title, url);
    }
    onPopState(fn) {
        // `Zone.current` will reference the zone that serves as an execution context
        // to some specific application, especially when `onPopState` is called.
        const zone = Zone.current;
        // Wrap any event listener into zone that is specific to some application.
        // The main issue is `back/forward` buttons of browsers, because they invoke
        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`
        // overrides `history.replaceState` Angular's zone cannot intercept this event.
        // Only the root zone is able to intercept all events.
        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details
        fn = zone.wrap(fn, this.source);
        const onPopStateListener = (event) => {
            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added
            // by `single-spa` starting from `5.4` version. We need this check because we want
            // to skip "unnatural" PopStateEvents, the one caused by `single-spa`.
            const popStateEventWasDispatchedBySingleSpa = !!event
                .singleSpa;
            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {
                this.skipNextPopState = false;
            }
            else {
                fn(event);
            }
        };
        return super.onPopState(onPopStateListener);
    }
}
/** @nocollapse */ SingleSpaPlatformLocation.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: SingleSpaPlatformLocation, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ SingleSpaPlatformLocation.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: SingleSpaPlatformLocation });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: SingleSpaPlatformLocation, decorators: [{
            type: Injectable
        }] });
/**
 * The `PlatformLocation` class is an "injectee" of the `PathLocationStrategy`,
 * which creates `Subject` internally for listening on `popstate` events. We want
 * to provide this class in the most top injector that's used during bootstrapping.
 */
export function getSingleSpaExtraProviders() {
    return [
        {
            provide: SingleSpaPlatformLocation,
            deps: [[new Inject(DOCUMENT)]],
        },
        {
            provide: PlatformLocation,
            useExisting: SingleSpaPlatformLocation,
        },
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmEtcHJvdmlkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL2V4dHJhLXByb3ZpZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixnQkFBZ0IsRUFHaEIsUUFBUSxHQUNULE1BQU0saUJBQWlCLENBQUM7O0FBS3pCLE1BQU0sT0FBTyx5QkFBMEIsU0FBUSx1QkFBdUI7SUFEdEU7O1FBRUUsaUVBQWlFO1FBQ2pFLDBDQUEwQztRQUNsQyxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFaEIsV0FBTSxHQUFHLGtDQUFrQyxDQUFDO0tBeUM5RDtJQXZDQyxTQUFTLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQzlDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxZQUFZLENBQUMsS0FBVSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQ2pELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxVQUFVLENBQUMsRUFBMEI7UUFDbkMsNkVBQTZFO1FBQzdFLHdFQUF3RTtRQUN4RSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBRTFCLDBFQUEwRTtRQUMxRSw0RUFBNEU7UUFDNUUsNkVBQTZFO1FBQzdFLCtFQUErRTtRQUMvRSxzREFBc0Q7UUFDdEQsa0ZBQWtGO1FBQ2xGLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFaEMsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQTBCLEVBQUUsRUFBRTtZQUN4RCxvRkFBb0Y7WUFDcEYsa0ZBQWtGO1lBQ2xGLHNFQUFzRTtZQUN0RSxNQUFNLHFDQUFxQyxHQUFHLENBQUMsQ0FBRSxLQUEyQztpQkFDekYsU0FBUyxDQUFDO1lBRWIsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLElBQUkscUNBQXFDLEVBQUU7Z0JBQ2xFLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7YUFDL0I7aUJBQU07Z0JBQ0wsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ1g7UUFDSCxDQUFDLENBQUM7UUFFRixPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUM5QyxDQUFDOzt5SUE3Q1UseUJBQXlCOzZJQUF6Qix5QkFBeUI7MkZBQXpCLHlCQUF5QjtrQkFEckMsVUFBVTs7QUFpRFg7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSwwQkFBMEI7SUFDeEMsT0FBTztRQUNMO1lBQ0UsT0FBTyxFQUFFLHlCQUF5QjtZQUNsQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDL0I7UUFDRDtZQUNFLE9BQU8sRUFBRSxnQkFBZ0I7WUFDekIsV0FBVyxFQUFFLHlCQUF5QjtTQUN2QztLQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgU3RhdGljUHJvdmlkZXIsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24sXG4gIFBsYXRmb3JtTG9jYXRpb24sXG4gIExvY2F0aW9uQ2hhbmdlRXZlbnQsXG4gIExvY2F0aW9uQ2hhbmdlTGlzdGVuZXIsXG4gIERPQ1VNRU5ULFxufSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5kZWNsYXJlIGNvbnN0IFpvbmU6IGFueTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gZXh0ZW5kcyBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbiB7XG4gIC8vIFRoaXMgaXMgYSBzaW1wbGUgbWFya2VyIHRoYXQgaGVscHMgdXMgdG8gaWdub3JlIFBvcFN0YXRlRXZlbnRzXG4gIC8vIHRoYXQgd2FzIG5vdCBkaXNwYXRjaGVkIGJ5IHRoZSBicm93c2VyLlxuICBwcml2YXRlIHNraXBOZXh0UG9wU3RhdGUgPSBmYWxzZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZSA9ICdXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjpwb3BzdGF0ZSc7XG5cbiAgcHVzaFN0YXRlKHN0YXRlOiBhbnksIHRpdGxlOiBzdHJpbmcsIHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5za2lwTmV4dFBvcFN0YXRlID0gdHJ1ZTtcbiAgICBzdXBlci5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICB9XG5cbiAgcmVwbGFjZVN0YXRlKHN0YXRlOiBhbnksIHRpdGxlOiBzdHJpbmcsIHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5za2lwTmV4dFBvcFN0YXRlID0gdHJ1ZTtcbiAgICBzdXBlci5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICB9XG5cbiAgb25Qb3BTdGF0ZShmbjogTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcik6IFZvaWRGdW5jdGlvbiB7XG4gICAgLy8gYFpvbmUuY3VycmVudGAgd2lsbCByZWZlcmVuY2UgdGhlIHpvbmUgdGhhdCBzZXJ2ZXMgYXMgYW4gZXhlY3V0aW9uIGNvbnRleHRcbiAgICAvLyB0byBzb21lIHNwZWNpZmljIGFwcGxpY2F0aW9uLCBlc3BlY2lhbGx5IHdoZW4gYG9uUG9wU3RhdGVgIGlzIGNhbGxlZC5cbiAgICBjb25zdCB6b25lID0gWm9uZS5jdXJyZW50O1xuXG4gICAgLy8gV3JhcCBhbnkgZXZlbnQgbGlzdGVuZXIgaW50byB6b25lIHRoYXQgaXMgc3BlY2lmaWMgdG8gc29tZSBhcHBsaWNhdGlvbi5cbiAgICAvLyBUaGUgbWFpbiBpc3N1ZSBpcyBgYmFjay9mb3J3YXJkYCBidXR0b25zIG9mIGJyb3dzZXJzLCBiZWNhdXNlIHRoZXkgaW52b2tlXG4gICAgLy8gYGhpc3RvcnkuYmFja3xmb3J3YXJkYCB3aGljaCBkaXNwYXRjaCBgcG9wc3RhdGVgIGV2ZW50LiBTaW5jZSBgc2luZ2xlLXNwYWBcbiAgICAvLyBvdmVycmlkZXMgYGhpc3RvcnkucmVwbGFjZVN0YXRlYCBBbmd1bGFyJ3Mgem9uZSBjYW5ub3QgaW50ZXJjZXB0IHRoaXMgZXZlbnQuXG4gICAgLy8gT25seSB0aGUgcm9vdCB6b25lIGlzIGFibGUgdG8gaW50ZXJjZXB0IGFsbCBldmVudHMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5nbGUtc3BhL3NpbmdsZS1zcGEtYW5ndWxhci9pc3N1ZXMvOTQgZm9yIG1vcmUgZGV0YWlsc1xuICAgIGZuID0gem9uZS53cmFwKGZuLCB0aGlzLnNvdXJjZSk7XG5cbiAgICBjb25zdCBvblBvcFN0YXRlTGlzdGVuZXIgPSAoZXZlbnQ6IExvY2F0aW9uQ2hhbmdlRXZlbnQpID0+IHtcbiAgICAgIC8vIFRoZSBgTG9jYXRpb25DaGFuZ2VFdmVudGAgZG9lc24ndCBoYXZlIHRoZSBgc2luZ2xlU3BhYCBwcm9wZXJ0eSwgc2luY2UgaXQncyBhZGRlZFxuICAgICAgLy8gYnkgYHNpbmdsZS1zcGFgIHN0YXJ0aW5nIGZyb20gYDUuNGAgdmVyc2lvbi4gV2UgbmVlZCB0aGlzIGNoZWNrIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgLy8gdG8gc2tpcCBcInVubmF0dXJhbFwiIFBvcFN0YXRlRXZlbnRzLCB0aGUgb25lIGNhdXNlZCBieSBgc2luZ2xlLXNwYWAuXG4gICAgICBjb25zdCBwb3BTdGF0ZUV2ZW50V2FzRGlzcGF0Y2hlZEJ5U2luZ2xlU3BhID0gISEoZXZlbnQgYXMgdW5rbm93biBhcyB7IHNpbmdsZVNwYTogYm9vbGVhbiB9KVxuICAgICAgICAuc2luZ2xlU3BhO1xuXG4gICAgICBpZiAodGhpcy5za2lwTmV4dFBvcFN0YXRlICYmIHBvcFN0YXRlRXZlbnRXYXNEaXNwYXRjaGVkQnlTaW5nbGVTcGEpIHtcbiAgICAgICAgdGhpcy5za2lwTmV4dFBvcFN0YXRlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbihldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzdXBlci5vblBvcFN0YXRlKG9uUG9wU3RhdGVMaXN0ZW5lcik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYFBsYXRmb3JtTG9jYXRpb25gIGNsYXNzIGlzIGFuIFwiaW5qZWN0ZWVcIiBvZiB0aGUgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCxcbiAqIHdoaWNoIGNyZWF0ZXMgYFN1YmplY3RgIGludGVybmFsbHkgZm9yIGxpc3RlbmluZyBvbiBgcG9wc3RhdGVgIGV2ZW50cy4gV2Ugd2FudFxuICogdG8gcHJvdmlkZSB0aGlzIGNsYXNzIGluIHRoZSBtb3N0IHRvcCBpbmplY3RvciB0aGF0J3MgdXNlZCBkdXJpbmcgYm9vdHN0cmFwcGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpbmdsZVNwYUV4dHJhUHJvdmlkZXJzKCk6IFN0YXRpY1Byb3ZpZGVyW10ge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24sXG4gICAgICBkZXBzOiBbW25ldyBJbmplY3QoRE9DVU1FTlQpXV0sXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBQbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgdXNlRXhpc3Rpbmc6IFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24sXG4gICAgfSxcbiAgXTtcbn1cbiJdfQ==