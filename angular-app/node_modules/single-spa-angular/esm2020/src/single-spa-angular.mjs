import { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';
import { SingleSpaPlatformLocation } from './extra-providers';
const defaultOptions = {
    // Required options that will be set by the library consumer.
    NgZone: null,
    bootstrapFunction: null,
    template: null,
    // Optional options
    Router: undefined,
    domElementGetter: undefined,
    updateFunction: () => Promise.resolve(),
    bootstrappedNgModuleRefOrAppRef: null,
};
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export function singleSpaAngular(userOptions) {
    if (NG_DEV_MODE && typeof userOptions !== 'object') {
        throw Error('single-spa-angular requires a configuration object');
    }
    const options = {
        ...defaultOptions,
        ...userOptions,
    };
    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {
        throw Error('single-spa-angular must be passed an options.bootstrapFunction');
    }
    if (NG_DEV_MODE && typeof options.template !== 'string') {
        throw Error('single-spa-angular must be passed options.template string');
    }
    if (NG_DEV_MODE && !options.NgZone) {
        throw Error(`single-spa-angular must be passed the NgZone option`);
    }
    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {
        // We call `console.warn` except of throwing `new Error()` since this will not
        // be a breaking change.
        console.warn(`single-spa-angular must be passed the NavigationStart option`);
    }
    return {
        bootstrap: bootstrap.bind(null, options),
        mount: mount.bind(null, options),
        unmount: unmount.bind(null, options),
        update: options.updateFunction,
    };
}
async function bootstrap(options, props) {
    // Angular provides an opportunity to develop `zone-less` application, where developers
    // have to trigger change detection manually.
    // See https://angular.io/guide/zone#noopzone
    if (options.NgZone === 'noop') {
        return;
    }
    // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.
    options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`;
    // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.
    // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,
    // https://github.com/single-spa/single-spa-angular/issues/47,
    // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,
    // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257
    options.NgZone.isInAngularZone = () => {
        // @ts-ignore
        return window.Zone.current._properties[options.zoneIdentifier] === true;
    };
    options.routingEventListener = () => {
        options.bootstrappedNgZone.run(() => {
            // See https://github.com/single-spa/single-spa-angular/issues/86
            // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work
            // unless we tell Zone that something happened
        });
    };
}
async function mount(options, props) {
    getContainerElementAndSetTemplate(options, props);
    const bootstrapPromise = options.bootstrapFunction(props);
    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {
        throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);
    }
    const ngModuleRefOrAppRef = await bootstrapPromise;
    if (NG_DEV_MODE) {
        if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {
            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);
        }
    }
    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);
    const ngZoneEnabled = options.NgZone !== 'noop';
    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.
    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.
    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use
    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.
    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {
        throw new Error(`
      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?
    `);
    }
    const bootstrappedOptions = options;
    if (ngZoneEnabled) {
        const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);
        const zoneIdentifier = bootstrappedOptions.zoneIdentifier;
        // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`
        // function was not called.
        if (singleSpaPlatformLocation !== null) {
            skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);
        }
        bootstrappedOptions.bootstrappedNgZone = ngZone;
        bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;
        window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);
    }
    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;
    return ngModuleRefOrAppRef;
}
function unmount(options) {
    return Promise.resolve().then(() => {
        if (options.routingEventListener) {
            window.removeEventListener('single-spa:routing-event', options.routingEventListener);
        }
        options.bootstrappedNgModuleRefOrAppRef.destroy();
        options.bootstrappedNgModuleRefOrAppRef = null;
    });
}
function skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {
    if (!options.NavigationStart) {
        // As discussed we don't do anything right now if the developer doesn't provide
        // `options.NavigationStart` since this might be a breaking change.
        return;
    }
    const router = ngModuleRefOrAppRef.injector.get(options.Router);
    const subscription = router.events.subscribe((event) => {
        if (event instanceof options.NavigationStart) {
            const currentNavigation = router.getCurrentNavigation();
            // This listener will be set up for each Angular application
            // that has routing capabilities.
            // We set `skipLocationChange` for each non-imperative navigation,
            // Angular router checks under the hood if it has to change
            // the browser URL or not.
            // If `skipLocationChange` is truthy then Angular router will not call
            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.
            if (currentNavigation.trigger !== 'imperative') {
                currentNavigation.extras.skipLocationChange = true;
                currentNavigation.extras.replaceUrl = false;
            }
        }
    });
    // The `ApplicationRef` also has `onDestroy` method, but it's marked as internal.
    ngModuleRefOrAppRef['onDestroy'](() => {
        subscription.unsubscribe();
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xlLXNwYS1hbmd1bGFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL3NpbmdsZS1zcGEtYW5ndWxhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUVqRixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUc5RCxNQUFNLGNBQWMsR0FBRztJQUNyQiw2REFBNkQ7SUFDN0QsTUFBTSxFQUFFLElBQUs7SUFDYixpQkFBaUIsRUFBRSxJQUFLO0lBQ3hCLFFBQVEsRUFBRSxJQUFLO0lBQ2YsbUJBQW1CO0lBQ25CLE1BQU0sRUFBRSxTQUFTO0lBQ2pCLGdCQUFnQixFQUFFLFNBQVM7SUFDM0IsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFDdkMsK0JBQStCLEVBQUUsSUFBSTtDQUN0QyxDQUFDO0FBTUYsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUVsRSxNQUFNLFVBQVUsZ0JBQWdCLENBQUksV0FBdUM7SUFDekUsSUFBSSxXQUFXLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1FBQ2xELE1BQU0sS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDbkU7SUFFRCxNQUFNLE9BQU8sR0FBNEI7UUFDdkMsR0FBRyxjQUFjO1FBQ2pCLEdBQUcsV0FBVztLQUNmLENBQUM7SUFFRixJQUFJLFdBQVcsSUFBSSxPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7UUFDbEUsTUFBTSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUMvRTtJQUVELElBQUksV0FBVyxJQUFJLE9BQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7UUFDdkQsTUFBTSxLQUFLLENB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QUFDO0FBRUQsU0FBUyxnREFBZ0QsQ0FDdkQsbUJBQXNELEVBQ3RELE9BQWdDO0lBRWhDLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFO1FBQzVCLCtFQUErRTtRQUMvRSxtRUFBbUU7UUFDbkUsT0FBTztLQUNSO0lBRUQsTUFBTSxNQUFNLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEUsTUFBTSxZQUFZLEdBQWlCLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBVSxFQUFFLEVBQUU7UUFDeEUsSUFBSSxLQUFLLFlBQVksT0FBTyxDQUFDLGVBQWdCLEVBQUU7WUFDN0MsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUN4RCw0REFBNEQ7WUFDNUQsaUNBQWlDO1lBQ2pDLGtFQUFrRTtZQUNsRSwyREFBMkQ7WUFDM0QsMEJBQTBCO1lBQzFCLHNFQUFzRTtZQUN0RSwwRkFBMEY7WUFDMUYsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEtBQUssWUFBWSxFQUFFO2dCQUM5QyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO2dCQUNuRCxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQzthQUM3QztTQUNGO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxpRkFBaUY7SUFDakYsbUJBQW1CLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxFQUFFO1FBQ3BDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM3QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBsaWNhdGlvblJlZiwgTmdNb2R1bGVSZWYsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMaWZlQ3ljbGVzIH0gZnJvbSAnc2luZ2xlLXNwYSc7XG5pbXBvcnQgeyBnZXRDb250YWluZXJFbGVtZW50QW5kU2V0VGVtcGxhdGUgfSBmcm9tICdzaW5nbGUtc3BhLWFuZ3VsYXIvaW50ZXJuYWxzJztcblxuaW1wb3J0IHsgU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiB9IGZyb20gJy4vZXh0cmEtcHJvdmlkZXJzJztcbmltcG9ydCB7IFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zLCBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gUmVxdWlyZWQgb3B0aW9ucyB0aGF0IHdpbGwgYmUgc2V0IGJ5IHRoZSBsaWJyYXJ5IGNvbnN1bWVyLlxuICBOZ1pvbmU6IG51bGwhLFxuICBib290c3RyYXBGdW5jdGlvbjogbnVsbCEsXG4gIHRlbXBsYXRlOiBudWxsISxcbiAgLy8gT3B0aW9uYWwgb3B0aW9uc1xuICBSb3V0ZXI6IHVuZGVmaW5lZCxcbiAgZG9tRWxlbWVudEdldHRlcjogdW5kZWZpbmVkLCAvLyBvbmx5IG9wdGlvbmFsIGlmIHlvdSBwcm92aWRlIGEgZG9tRWxlbWVudEdldHRlciBhcyBhIGN1c3RvbSBwcm9wXG4gIHVwZGF0ZUZ1bmN0aW9uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcbiAgYm9vdHN0cmFwcGVkTmdNb2R1bGVSZWZPckFwcFJlZjogbnVsbCxcbn07XG5cbi8vIFRoaXMgd2lsbCBiZSBwcm92aWRlZCB0aHJvdWdoIFRlcnNlciBnbG9iYWwgZGVmaW5pdGlvbnMgYnkgQW5ndWxhciBDTEkuIFRoaXMgd2lsbFxuLy8gaGVscCB0byB0cmVlLXNoYWtlIGF3YXkgdGhlIGNvZGUgdW5uZWVkZWQgZm9yIHByb2R1Y3Rpb24gYnVuZGxlcy5cbmRlY2xhcmUgY29uc3QgbmdEZXZNb2RlOiBib29sZWFuO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZVNwYUFuZ3VsYXI8VD4odXNlck9wdGlvbnM6IFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zPFQ+KTogTGlmZUN5Y2xlczxUPiB7XG4gIGlmIChOR19ERVZfTU9ERSAmJiB0eXBlb2YgdXNlck9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ3NpbmdsZS1zcGEtYW5ndWxhciByZXF1aXJlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi51c2VyT3B0aW9ucyxcbiAgfTtcblxuICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBFcnJvcignc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIGFuIG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmIChOR19ERVZfTU9ERSAmJiB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBFcnJvcignc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIG9wdGlvbnMudGVtcGxhdGUgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoTkdfREVWX01PREUgJiYgIW9wdGlvbnMuTmdab25lKSB7XG4gICAgdGhyb3cgRXJyb3IoYHNpbmdsZS1zcGEtYW5ndWxhciBtdXN0IGJlIHBhc3NlZCB0aGUgTmdab25lIG9wdGlvbmApO1xuICB9XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmIG9wdGlvbnMuUm91dGVyICYmICFvcHRpb25zLk5hdmlnYXRpb25TdGFydCkge1xuICAgIC8vIFdlIGNhbGwgYGNvbnNvbGUud2FybmAgZXhjZXB0IG9mIHRocm93aW5nIGBuZXcgRXJyb3IoKWAgc2luY2UgdGhpcyB3aWxsIG5vdFxuICAgIC8vIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICAgIGNvbnNvbGUud2Fybihgc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIHRoZSBOYXZpZ2F0aW9uU3RhcnQgb3B0aW9uYCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvb3RzdHJhcDogYm9vdHN0cmFwLmJpbmQobnVsbCwgb3B0aW9ucyBhcyBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyksXG4gICAgbW91bnQ6IG1vdW50LmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgdW5tb3VudDogdW5tb3VudC5iaW5kKG51bGwsIG9wdGlvbnMgYXMgQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpLFxuICAgIHVwZGF0ZTogb3B0aW9ucy51cGRhdGVGdW5jdGlvbixcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYm9vdHN0cmFwKG9wdGlvbnM6IEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zLCBwcm9wczogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIEFuZ3VsYXIgcHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGV2ZWxvcCBgem9uZS1sZXNzYCBhcHBsaWNhdGlvbiwgd2hlcmUgZGV2ZWxvcGVyc1xuICAvLyBoYXZlIHRvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseS5cbiAgLy8gU2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS96b25lI25vb3B6b25lXG4gIGlmIChvcHRpb25zLk5nWm9uZSA9PT0gJ25vb3AnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSW4gb3JkZXIgZm9yIG11bHRpcGxlIEFuZ3VsYXIgYXBwcyB0byB3b3JrIGNvbmN1cnJlbnRseSBvbiBhIHBhZ2UsIHRoZXkgZWFjaCBuZWVkIGEgdW5pcXVlIGlkZW50aWZpZXIuXG4gIG9wdGlvbnMuem9uZUlkZW50aWZpZXIgPSBgc2luZ2xlLXNwYS1hbmd1bGFyOiR7cHJvcHMubmFtZSB8fCBwcm9wcy5hcHBOYW1lfWA7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2ssIHNpbmNlIE5nWm9uZSBkb2Vzbid0IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHByb3BlcnR5IHRoYXQgaWRlbnRpZmllcyB5b3VyIHpvbmUuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUGxhY2VNZS1TQVMvc2luZ2xlLXNwYS1hbmd1bGFyLWNsaS9pc3N1ZXMvMzMsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5nbGUtc3BhL3NpbmdsZS1zcGEtYW5ndWxhci9pc3N1ZXMvNDcsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9hMTRkYzJkN2E0ODIxYTE5ZjIwYTk1NDcwNTNhNTczNDc5OGY1NDFlL3BhY2thZ2VzL2NvcmUvc3JjL3pvbmUvbmdfem9uZS50cyNMMTQ0LFxuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL2ExNGRjMmQ3YTQ4MjFhMTlmMjBhOTU0NzA1M2E1NzM0Nzk4ZjU0MWUvcGFja2FnZXMvY29yZS9zcmMvem9uZS9uZ196b25lLnRzI0wyNTdcbiAgb3B0aW9ucy5OZ1pvbmUuaXNJbkFuZ3VsYXJab25lID0gKCkgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gd2luZG93LlpvbmUuY3VycmVudC5fcHJvcGVydGllc1tvcHRpb25zLnpvbmVJZGVudGlmaWVyXSA9PT0gdHJ1ZTtcbiAgfTtcblxuICBvcHRpb25zLnJvdXRpbmdFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgIG9wdGlvbnMuYm9vdHN0cmFwcGVkTmdab25lIS5ydW4oKCkgPT4ge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5nbGUtc3BhL3NpbmdsZS1zcGEtYW5ndWxhci9pc3N1ZXMvODZcbiAgICAgIC8vIFpvbmUgaXMgdW5hd2FyZSBvZiB0aGUgc2luZ2xlLXNwYSBuYXZpZ2F0aW9uIGNoYW5nZSBhbmQgc28gQW5ndWxhciBjaGFuZ2UgZGV0ZWN0aW9uIGRvZXNuJ3Qgd29ya1xuICAgICAgLy8gdW5sZXNzIHdlIHRlbGwgWm9uZSB0aGF0IHNvbWV0aGluZyBoYXBwZW5lZFxuICAgIH0pO1xuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBtb3VudChcbiAgb3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsXG4gIHByb3BzOiBhbnksXG4pOiBQcm9taXNlPE5nTW9kdWxlUmVmPGFueT4gfCBBcHBsaWNhdGlvblJlZj4ge1xuICBnZXRDb250YWluZXJFbGVtZW50QW5kU2V0VGVtcGxhdGUob3B0aW9ucywgcHJvcHMpO1xuXG4gIGNvbnN0IGJvb3RzdHJhcFByb21pc2UgPSBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uKHByb3BzKTtcblxuICBpZiAoTkdfREVWX01PREUgJiYgIShib290c3RyYXBQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBzaW5nbGUtc3BhLWFuZ3VsYXI6IHRoZSBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgcHJvbWlzZSwgYnV0IGluc3RlYWQgcmV0dXJuZWQgYSAnJHt0eXBlb2YgYm9vdHN0cmFwUHJvbWlzZX0nIHRoYXQgaXMgbm90IGEgUHJvbWlzZWAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG5nTW9kdWxlUmVmT3JBcHBSZWY6IE5nTW9kdWxlUmVmPGFueT4gfCBBcHBsaWNhdGlvblJlZiA9IGF3YWl0IGJvb3RzdHJhcFByb21pc2U7XG5cbiAgaWYgKE5HX0RFVl9NT0RFKSB7XG4gICAgaWYgKCFuZ01vZHVsZVJlZk9yQXBwUmVmIHx8IHR5cGVvZiBuZ01vZHVsZVJlZk9yQXBwUmVmLmRlc3Ryb3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgc2luZ2xlLXNwYS1hbmd1bGFyOiB0aGUgb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UgdGhhdCBkaWQgbm90IHJlc29sdmUgd2l0aCBhIHZhbGlkIEFuZ3VsYXIgbW9kdWxlIG9yIEFwcGxpY2F0aW9uUmVmLiBEaWQgeW91IGNhbGwgcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZSgpIGNvcnJlY3RseT9gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uOiBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uIHwgbnVsbCA9XG4gICAgbmdNb2R1bGVSZWZPckFwcFJlZi5pbmplY3Rvci5nZXQoU2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiwgbnVsbCk7XG5cbiAgY29uc3Qgbmdab25lRW5hYmxlZCA9IG9wdGlvbnMuTmdab25lICE9PSAnbm9vcCc7XG5cbiAgLy8gVGhlIHVzZXIgaGFzIHRvIHByb3ZpZGUgYEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uYCBvbmx5IGlmIGhpcyBhcHBsaWNhdGlvbiB1c2VzIHJvdXRpbmcuXG4gIC8vIFNvIGlmIGhlIHByb3ZpZGVkIGBSb3V0ZXJgIGJ1dCBkaWRuJ3QgcHJvdmlkZSBgQnJvd3NlclBsYXRmb3JtTG9jYXRpb25gIHRoZW4gd2UgaGF2ZSB0byBpbmZvcm0gaGltLlxuICAvLyBBbHNvIGBnZXRTaW5nbGVTcGFFeHRyYVByb3ZpZGVycygpYCBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaWYgdGhlIHVzZXIgZG9lc24ndCB1c2VcbiAgLy8gYHpvbmUtbGVzc2AgY2hhbmdlIGRldGVjdGlvbiwgaWYgYE5nWm9uZWAgaXMgYG5vb3BgIHRoZW4gd2UgY2FuIHNraXAgaXQuXG4gIGlmIChOR19ERVZfTU9ERSAmJiBuZ1pvbmVFbmFibGVkICYmIG9wdGlvbnMuUm91dGVyICYmIHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgc2luZ2xlLXNwYS1hbmd1bGFyOiBjb3VsZCBub3QgcmV0cmlldmUgZXh0cmEgcHJvdmlkZXJzIGZyb20gdGhlIHBsYXRmb3JtIGluamVjdG9yLiBEaWQgeW91IGNhbGwgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyhnZXRTaW5nbGVTcGFFeHRyYVByb3ZpZGVycygpKS5ib290c3RyYXBNb2R1bGUoKT9cbiAgICBgKTtcbiAgfVxuXG4gIGNvbnN0IGJvb3RzdHJhcHBlZE9wdGlvbnMgPSBvcHRpb25zIGFzIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zO1xuXG4gIGlmIChuZ1pvbmVFbmFibGVkKSB7XG4gICAgY29uc3Qgbmdab25lOiBOZ1pvbmUgPSBuZ01vZHVsZVJlZk9yQXBwUmVmLmluamVjdG9yLmdldChvcHRpb25zLk5nWm9uZSk7XG4gICAgY29uc3Qgem9uZUlkZW50aWZpZXI6IHN0cmluZyA9IGJvb3RzdHJhcHBlZE9wdGlvbnMuem9uZUlkZW50aWZpZXIhO1xuXG4gICAgLy8gYE5nWm9uZWAgY2FuIGJlIGVuYWJsZWQgYnV0IHJvdXRpbmcgbWF5IG5vdCBiZSB1c2VkIHRodXMgYGdldFNpbmdsZVNwYUV4dHJhUHJvdmlkZXJzKClgXG4gICAgLy8gZnVuY3Rpb24gd2FzIG5vdCBjYWxsZWQuXG4gICAgaWYgKHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHNraXBMb2NhdGlvbkNoYW5nZU9uTm9uSW1wZXJhdGl2ZVJvdXRpbmdUcmlnZ2VycyhuZ01vZHVsZVJlZk9yQXBwUmVmLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBib290c3RyYXBwZWRPcHRpb25zLmJvb3RzdHJhcHBlZE5nWm9uZSA9IG5nWm9uZTtcbiAgICBib290c3RyYXBwZWRPcHRpb25zLmJvb3RzdHJhcHBlZE5nWm9uZVsnX2lubmVyJ10uX3Byb3BlcnRpZXNbem9uZUlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2luZ2xlLXNwYTpyb3V0aW5nLWV2ZW50JywgYm9vdHN0cmFwcGVkT3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lciEpO1xuICB9XG5cbiAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmID0gbmdNb2R1bGVSZWZPckFwcFJlZjtcbiAgcmV0dXJuIG5nTW9kdWxlUmVmT3JBcHBSZWY7XG59XG5cbmZ1bmN0aW9uIHVubW91bnQob3B0aW9uczogQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmIChvcHRpb25zLnJvdXRpbmdFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2luZ2xlLXNwYTpyb3V0aW5nLWV2ZW50Jywgb3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5ib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmIS5kZXN0cm95KCk7XG4gICAgb3B0aW9ucy5ib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmID0gbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNraXBMb2NhdGlvbkNoYW5nZU9uTm9uSW1wZXJhdGl2ZVJvdXRpbmdUcmlnZ2VycyhcbiAgbmdNb2R1bGVSZWZPckFwcFJlZjogTmdNb2R1bGVSZWY8YW55PiB8IEFwcGxpY2F0aW9uUmVmLFxuICBvcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyxcbik6IHZvaWQge1xuICBpZiAoIW9wdGlvbnMuTmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgLy8gQXMgZGlzY3Vzc2VkIHdlIGRvbid0IGRvIGFueXRoaW5nIHJpZ2h0IG5vdyBpZiB0aGUgZGV2ZWxvcGVyIGRvZXNuJ3QgcHJvdmlkZVxuICAgIC8vIGBvcHRpb25zLk5hdmlnYXRpb25TdGFydGAgc2luY2UgdGhpcyBtaWdodCBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCByb3V0ZXIgPSBuZ01vZHVsZVJlZk9yQXBwUmVmLmluamVjdG9yLmdldChvcHRpb25zLlJvdXRlcik7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoKGV2ZW50OiBhbnkpID0+IHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBvcHRpb25zLk5hdmlnYXRpb25TdGFydCEpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROYXZpZ2F0aW9uID0gcm91dGVyLmdldEN1cnJlbnROYXZpZ2F0aW9uKCk7XG4gICAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgc2V0IHVwIGZvciBlYWNoIEFuZ3VsYXIgYXBwbGljYXRpb25cbiAgICAgIC8vIHRoYXQgaGFzIHJvdXRpbmcgY2FwYWJpbGl0aWVzLlxuICAgICAgLy8gV2Ugc2V0IGBza2lwTG9jYXRpb25DaGFuZ2VgIGZvciBlYWNoIG5vbi1pbXBlcmF0aXZlIG5hdmlnYXRpb24sXG4gICAgICAvLyBBbmd1bGFyIHJvdXRlciBjaGVja3MgdW5kZXIgdGhlIGhvb2QgaWYgaXQgaGFzIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIGJyb3dzZXIgVVJMIG9yIG5vdC5cbiAgICAgIC8vIElmIGBza2lwTG9jYXRpb25DaGFuZ2VgIGlzIHRydXRoeSB0aGVuIEFuZ3VsYXIgcm91dGVyIHdpbGwgbm90IGNhbGxcbiAgICAgIC8vIGBzZXRCcm93c2VyVXJsKClgIHdoaWNoIGNhbGxzIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZSgpYCBhbmQgZGlzcGF0Y2hlcyBgcG9wc3RhdGVgIGV2ZW50LlxuICAgICAgaWYgKGN1cnJlbnROYXZpZ2F0aW9uLnRyaWdnZXIgIT09ICdpbXBlcmF0aXZlJykge1xuICAgICAgICBjdXJyZW50TmF2aWdhdGlvbi5leHRyYXMuc2tpcExvY2F0aW9uQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudE5hdmlnYXRpb24uZXh0cmFzLnJlcGxhY2VVcmwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZSBgQXBwbGljYXRpb25SZWZgIGFsc28gaGFzIGBvbkRlc3Ryb3lgIG1ldGhvZCwgYnV0IGl0J3MgbWFya2VkIGFzIGludGVybmFsLlxuICBuZ01vZHVsZVJlZk9yQXBwUmVmWydvbkRlc3Ryb3knXSgoKSA9PiB7XG4gICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH0pO1xufVxuIl19