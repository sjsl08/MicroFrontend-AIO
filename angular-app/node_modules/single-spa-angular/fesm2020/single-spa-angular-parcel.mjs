import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Input, NgModule } from '@angular/core';

class ParcelComponent {
    constructor(host) {
        this.host = host;
        this.config = null;
        this.mountParcel = null;
        this.onParcelMount = null;
        this.wrapWith = 'div';
        this.customProps = {};
        this.appendTo = null;
        this.handleError = (error) => console.error(error);
        this.hasError = false;
        this.wrapper = null;
        this.parcel = null;
        this.task = null;
    }
    ngOnChanges() {
        this.scheduleTask("update" /* Action.Update */, () => {
            if (this.parcel !== null && this.parcel.update) {
                return this.parcel.update(this.customProps);
            }
        });
    }
    ngOnInit() {
        this.scheduleTask("mount" /* Action.Mount */, () => {
            if ((typeof ngDevMode === 'undefined' || ngDevMode) && this.mountParcel === null) {
                throw new Error('single-spa-angular: the [mountParcel] binding is required when using the <parcel> component. You can either (1) import mountRootParcel from single-spa or (2) use the mountParcel prop provided to single-spa applications.');
            }
            this.wrapper = document.createElement(this.wrapWith);
            if (this.appendTo !== null) {
                this.appendTo.appendChild(this.wrapper);
            }
            else {
                this.host.nativeElement.appendChild(this.wrapper);
            }
            this.parcel = this.mountParcel(this.config, {
                ...this.customProps,
                domElement: this.wrapper,
            });
            if (this.onParcelMount !== null) {
                this.parcel.mountPromise.then(this.onParcelMount);
            }
            this.unmounted = false;
            return this.parcel.mountPromise;
        });
    }
    ngOnDestroy() {
        this.scheduleTask("unmount" /* Action.Unmount */, () => {
            if (this.parcel !== null && this.parcel.getStatus() === 'MOUNTED') {
                return this.parcel.unmount();
            }
        });
        if (this.wrapper !== null) {
            this.wrapper.parentNode.removeChild(this.wrapper);
        }
        this.unmounted = true;
    }
    scheduleTask(action, task) {
        if (this.hasError && action !== "unmount" /* Action.Unmount */) {
            // In an error state, we don't do anything anymore except for unmounting
            return;
        }
        this.task = (this.task || Promise.resolve())
            .then(() => {
            if (this.unmounted && action !== "unmount" /* Action.Unmount */) {
                // Never do anything once the angular component unmounts
                return;
            }
            return task();
        })
            .catch((error) => {
            this.task = Promise.resolve();
            this.hasError = true;
            if (error?.message) {
                error.message = `During '${action}', parcel threw an error: ${error.message}`;
            }
            if (typeof this.handleError === 'function') {
                this.handleError(error);
            }
            else {
                setTimeout(() => {
                    throw error;
                });
            }
            // No more things to do should be done -- the parcel is in an error state
            throw error;
        });
    }
}
/** @nocollapse */ ParcelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ParcelComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ ParcelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ParcelComponent, isStandalone: true, selector: "parcel", inputs: { config: "config", mountParcel: "mountParcel", onParcelMount: "onParcelMount", wrapWith: "wrapWith", customProps: "customProps", appendTo: "appendTo", handleError: "handleError" }, usesOnChanges: true, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ParcelComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'parcel',
                    template: '',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { config: [{
                type: Input
            }], mountParcel: [{
                type: Input
            }], onParcelMount: [{
                type: Input
            }], wrapWith: [{
                type: Input
            }], customProps: [{
                type: Input
            }], appendTo: [{
                type: Input
            }], handleError: [{
                type: Input
            }] } });

class ParcelModule {
}
/** @nocollapse */ ParcelModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ParcelModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ ParcelModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.2", ngImport: i0, type: ParcelModule, imports: [ParcelComponent], exports: [ParcelComponent] });
/** @nocollapse */ ParcelModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ParcelModule, imports: [ParcelComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ParcelModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ParcelComponent],
                    exports: [ParcelComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ParcelComponent, ParcelModule };
//# sourceMappingURL=single-spa-angular-parcel.mjs.map
