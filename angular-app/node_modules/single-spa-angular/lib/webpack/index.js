"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const find_up_1 = require("@angular/cli/src/utilities/find-up");
const externals_1 = require("./externals");
const remove_mini_css_extract_1 = require("./webpack-5/remove-mini-css-extract");
const defaultExtraOptions = {
    removeMiniCssExtract: true,
};
exports.default = (config, options, extraOptions) => {
    var _a, _b, _c, _d, _e;
    const libraryName = getLibraryName(config, options);
    extraOptions = Object.assign(Object.assign({}, defaultExtraOptions), extraOptions);
    const singleSpaConfig = {
        output: {
            library: libraryName,
            libraryTarget: (_b = (_a = options === null || options === void 0 ? void 0 : options.customWebpackConfig) === null || _a === void 0 ? void 0 : _a.libraryTarget) !== null && _b !== void 0 ? _b : 'umd',
            // `output.jsonpFunction` has been renamed to `output.chunkLoadingGlobal` in Webpack 5.
            chunkLoadingGlobal: 'webpackJsonp' + libraryName,
            devtoolNamespace: libraryName,
        },
        externals: ['zone.js'],
        devServer: {
            historyApiFallback: false,
            headers: {
                'Access-Control-Allow-Headers': '*',
            },
        },
        module: {
            rules: [{}],
        },
        devtool: resolveDevtool(options),
    };
    if ((_c = options === null || options === void 0 ? void 0 : options.customWebpackConfig) === null || _c === void 0 ? void 0 : _c.excludeAngularDependencies) {
        singleSpaConfig.externals.push(...externals_1.externals);
    }
    // Do not set the `client.webSocketURL` configuration if there's no host and port.
    if (((_d = config.devServer) === null || _d === void 0 ? void 0 : _d.host) && config.devServer.port) {
        singleSpaConfig.devServer.client = {
            webSocketURL: {
                hostname: config.devServer.host,
                port: config.devServer.port,
            },
        };
    }
    const mergedConfig = mergeConfigs(config, singleSpaConfig);
    if (mergedConfig.output.libraryTarget === 'system') {
        // Don't used named exports when exporting in System.register format.
        delete mergedConfig.output.library;
    }
    removePluginByName(mergedConfig.plugins, 'IndexHtmlWebpackPlugin');
    if (extraOptions.removeMiniCssExtract) {
        removeMiniCssExtract(mergedConfig);
    }
    if (Array.isArray(mergedConfig.entry.styles)) {
        // We want the global styles to be part of the "main" entry. The order of strings in this array
        // matters -- only the last item in the array will have its exports become the exports for the entire
        // webpack bundle
        mergedConfig.entry.main = [...mergedConfig.entry.styles, ...mergedConfig.entry.main];
    }
    else {
        // The `entry` doesn't have a `styles` property, which means we're on the Angular
        // 15+ version where `StylesWebpackPlugin` was introduced to resolve module resolution
        // issues related to Yarn PNP.
        const stylesWebpackPluginName = 'StylesWebpackPlugin';
        const stylesWebpackPlugin = mergedConfig.plugins.find((plugin) => plugin.constructor.name === stylesWebpackPluginName);
        const entryPoints = (_e = stylesWebpackPlugin === null || stylesWebpackPlugin === void 0 ? void 0 : stylesWebpackPlugin.options) === null || _e === void 0 ? void 0 : _e.entryPoints;
        if (entryPoints) {
            // The `ngGlobalStyle` is a Webpack query required by Angular to
            // apply a specific list of Webpack loaders to these files. There
            // are only two queries available: `ngGlobalStyle` and `ngResource`
            // (used for component styles).
            // Webpack would then do the following:
            // `{ use: globalStyleLoaders, resourceQuery: /\?ngGlobalStyle/ }`
            const query = `?ngGlobalStyle`;
            Object.keys(entryPoints).forEach(entryPoint => {
                // `styles` is the primary styles that must be loaded with the main entry point.
                if (entryPoint === 'styles') {
                    const styles = entryPoints.styles.map(path => `${path}${query}`);
                    mergedConfig.entry.main = [...styles, ...mergedConfig.entry.main];
                }
                else {
                    // Other entry points (which are lazy bundles) must be a part of entries to resolve
                    // to separate JS files.
                    mergedConfig.entry[entryPoint] = entryPoints[entryPoint].map(path => `${path}${query}`);
                }
            });
            removePluginByName(mergedConfig.plugins, stylesWebpackPluginName);
        }
    }
    // Remove bundles
    // Since Angular 8 supports differential loading it also
    // add `polyfills-es5` to Webpack entries. This is a fix for:
    // https://github.com/single-spa/single-spa-angular/issues/148
    if (mergedConfig.entry['polyfills-es5']) {
        delete mergedConfig.entry['polyfills-es5'];
    }
    delete mergedConfig.entry.polyfills;
    delete mergedConfig.entry.styles;
    delete mergedConfig.optimization.runtimeChunk;
    delete mergedConfig.optimization.splitChunks;
    return mergedConfig;
};
function removePluginByName(plugins, name) {
    const pluginIndex = plugins.findIndex(plugin => plugin.constructor.name === name);
    if (pluginIndex > -1) {
        plugins.splice(pluginIndex, 1);
    }
}
function removeMiniCssExtract(config) {
    (0, remove_mini_css_extract_1.removeMiniCssExtractRules)(config);
    removePluginByName(config.plugins, 'MiniCssExtractPlugin');
}
const logger = createLogger();
function getLibraryName(config, options) {
    var _a;
    if ((_a = options === null || options === void 0 ? void 0 : options.customWebpackConfig) === null || _a === void 0 ? void 0 : _a.libraryName) {
        return options.customWebpackConfig.libraryName;
    }
    const projectName = getProjectNameFromAngularJson(options) || getProjectNameFromWorkspaceJson(config);
    if (projectName)
        return projectName;
    logger.warn('Warning: single-spa-angular could not determine a library name to use and has used a default value.');
    logger.warn('This may cause issues if this app uses code-splitting or lazy loading.');
    if (!options) {
        logger.warn('You may also need to update extra-webpack.config.json.');
    }
    logger.warn('See <https://single-spa.js.org/docs/ecosystem-angular/#use-custom-webpack> for information on how to resolve this.');
    return 'angular_single_spa_project';
}
function getProjectNameFromAngularJson(options) {
    const angularJsonPath = (0, find_up_1.findUp)(['angular.json', '.angular.json', 'workspace.json'], process.cwd());
    if (!angularJsonPath)
        return null;
    const angularJson = JSON.parse(fs.readFileSync(angularJsonPath, 'utf8'));
    if (!angularJson.projects)
        return null;
    const projects = Object.keys(angularJson.projects);
    // if there is exactly one project in the workspace, then that must be this one.
    if (projects.length === 1)
        return projects[0];
    try {
        // If `projects.length > 1` then this means we're inside a monorepo workspace,
        // that might be an Nrwl Nx workspace. The Nx workspace can contain N different Angular applications.
        // In the following code we're trying to find an Nx project by the `main`
        // property which equals `apps/${applicationName}/src/main.single-spa.ts` and `options`
        // are bounded to the currently built application, so their values cannot differ.
        // We search by `architect.build` since any Angular application has an `architect` configuration
        // in `angular.json` and each `architect` has `build` target, thus any application can be built
        // via `ng build application`.
        return projects.find(project => angularJson.projects[project].architect.build.options.main === options.main);
    }
    catch (_a) {
        // If we reach here there are multiple (or zero) projects in angular.json
        // we cannot tell which one to use, so we will end up using the default.
        return null;
    }
}
/**
 * https://nx.dev/configuration/projectjson#project-configuration
 */
function getProjectNameFromWorkspaceJson(config) {
    // Ensure this is an Nrwl Nx workspace.
    const nxJsonPath = (0, find_up_1.findUp)('nx.json', process.cwd());
    if (!nxJsonPath)
        return null;
    try {
        // E.g. `/Users/username/single-spa-angular/apps/shop`.
        const [root] = config.resolve.roots;
        const workspaceJsonPath = (0, find_up_1.findUp)('workspace.json', process.cwd());
        // The `workspace.json` structure might be as follows:
        // {
        //   "version": 2,
        //   "projects": {
        //     "chat": "apps/chat",
        //     "shop": "apps/shop",
        //     "my-lib": "libs/my-lib"
        //   }
        // }
        const { projects } = JSON.parse(fs.readFileSync(workspaceJsonPath, 'utf8'));
        for (const [projectName, projectPath] of Object.entries(projects)) {
            // If `/Users/username/single-spa-angular/apps/shop` includes `apps/shop` then return `shop`.
            if (root.includes(projectPath)) {
                return projectName;
            }
        }
        return null;
    }
    catch (_a) {
        return null;
    }
}
function resolveDevtool(options) {
    // If `options.sourceMap = true` or `options.sourceMap.scripts = true` then
    // source maps are enabled for all scripts by default.
    const allSourceMapsEnabled = (options === null || options === void 0 ? void 0 : options.sourceMap) === true;
    const scriptsSourceMapsEnabled = typeof (options === null || options === void 0 ? void 0 : options.sourceMap) === 'object' && options.sourceMap.scripts === true;
    if (allSourceMapsEnabled || scriptsSourceMapsEnabled) {
        return 'source-map';
    }
    else {
        // If options are not provided then we shouldn't enable source maps since
        // it can worsen the build time and the developer will not even know about it.
        return false;
    }
}
function mergeConfigs(config, singleSpaConfig) {
    // eslint-disable-next-line
    const webpackMerge = require('webpack-merge');
    try {
        // If `merge.smart` is available then it means that Webpack 4 is used.
        return webpackMerge.smart(config, singleSpaConfig);
    }
    catch (_a) {
        // `merge.smart` has been dropped in `webpack-merge@5`.
        return webpackMerge.default(config, singleSpaConfig);
    }
}
function createLogger() {
    try {
        // If we're in an Nx workspace then use its logger.
        // eslint-disable-next-line
        const { output } = require('@nrwl/workspace');
        return {
            warn: (message) => output.warn({ title: message }),
        };
    }
    catch (_a) {
        // Otherwise, fallback to `console.warn`.
        return {
            warn: (message) => console.warn(message),
        };
    }
}
//# sourceMappingURL=index.js.map