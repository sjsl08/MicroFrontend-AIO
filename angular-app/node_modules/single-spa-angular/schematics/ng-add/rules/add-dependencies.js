"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDependencies = void 0;
const tslib_1 = require("tslib");
const https = require("https");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
function addDependencies() {
    const dependencies = [
        getSingleSpaDependency(),
        getSingleSpaAngularDependency(),
        getStyleLoaderDependency(),
        getAngularBuildersCustomWebpackDependency(),
    ];
    return (tree, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        try {
            for (var _d = true, dependencies_2 = tslib_1.__asyncValues(dependencies), dependencies_2_1; dependencies_2_1 = yield dependencies_2.next(), _a = dependencies_2_1.done, !_a;) {
                _c = dependencies_2_1.value;
                _d = false;
                try {
                    const dependency = _c;
                    (0, dependencies_1.addPackageJsonDependency)(tree, dependency);
                    context.logger.info(`Added '${dependency.name}' as a dependency`);
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = dependencies_2.return)) yield _b.call(dependencies_2);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
exports.addDependencies = addDependencies;
const { version, peerDependencies, dependencies } = require('../../../package.json');
function getSingleSpaDependency() {
    const singleSpaVersion = (peerDependencies === null || peerDependencies === void 0 ? void 0 : peerDependencies['single-spa']) || (dependencies === null || dependencies === void 0 ? void 0 : dependencies['single-spa']) || 'latest';
    return {
        name: 'single-spa',
        version: singleSpaVersion,
        overwrite: true,
        type: dependencies_1.NodeDependencyType.Default,
    };
}
function getSingleSpaAngularDependency() {
    return {
        name: 'single-spa-angular',
        version,
        overwrite: false,
        type: dependencies_1.NodeDependencyType.Default,
    };
}
function getStyleLoaderDependency() {
    return {
        name: 'style-loader',
        overwrite: false,
        type: dependencies_1.NodeDependencyType.Dev,
        version: (peerDependencies === null || peerDependencies === void 0 ? void 0 : peerDependencies['style-loader']) || (dependencies === null || dependencies === void 0 ? void 0 : dependencies['style-loader']) || 'latest',
    };
}
function getAngularBuildersCustomWebpackDependency() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return {
            name: '@angular-builders/custom-webpack',
            overwrite: false,
            type: dependencies_1.NodeDependencyType.Dev,
            version: yield resolveCustomWebpackVersion(),
        };
    });
}
function resolveCustomWebpackVersion() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let version;
        try {
            const major = yield resolveAngularMajorVersion();
            const versions = yield getCustomWebpackVersions();
            // Let's try to get all versions that might match the current major Angular version.
            // This can be:
            // `['12.0.0-beta.0', '12.0.0', '12.0.1-beta.0']`
            const majorVersions = versions.filter(version => version.startsWith(major));
            const majorBetaVersions = majorVersions.filter(version => version.match(/-beta/) !== null);
            const majorStableVersions = majorVersions.filter(version => version.match(/-beta/) === null);
            // Well, we'd want to use the stable version first of all, for instance, `12.0.0`, and if
            // no stable version is available, then we fall back to the beta version.
            // This can happen when the new Angular version is out and the `@angular-builders/custom-webpack`
            // hasn't released the stable compatible version yet.
            version = majorStableVersions.pop() || majorBetaVersions.pop() || 'latest';
        }
        catch (_a) {
            // We could actually initialize version with the `latest` value,
            // but let's be more imperative and fallback to the `latest` value
            // if any exception has occured previously.
            version = 'latest';
        }
        return version;
    });
}
function getCustomWebpackVersions() {
    return new Promise((resolve, reject) => {
        const request = https.get({
            protocol: 'https:',
            hostname: 'registry.npmjs.com',
            path: '/@angular-builders/custom-webpack',
        }, (response) => {
            const chunks = [];
            response
                .on('error', reject)
                .on('data', chunk => {
                chunks.push(chunk);
            })
                .on('end', () => {
                const response = JSON.parse(`${Buffer.concat(chunks)}`);
                const versions = Object.keys(response.versions);
                resolve(versions);
            });
        });
        request.on('error', reject).end();
    });
}
function resolveAngularMajorVersion() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (typeof jest !== 'undefined') {
            return (yield Promise.resolve().then(() => require('@angular/core'))).VERSION.major;
        }
        else {
            // Caretaker note: Angular 13 is no longer shipped with UMD bundles. It exports `.mjs` files only.
            // Thus `require('@angular/core')` throws an exception that `Must use import to load ES Module`.
            // The `await import('@angular/core')` is transformed by the TS compiler into this:
            // `yield Promise.resolve().then(() => require('@angular/core'))`.
            return (yield Function('return import("@angular/core")')()).VERSION.major;
        }
    });
}
//# sourceMappingURL=add-dependencies.js.map